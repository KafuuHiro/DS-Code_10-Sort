#pragma once
//插入排序分为直接插入排序和希尔排序。希尔排序是直接插入排序的优化

//
//------------------------直接插入排序(升序)-------------------//
//空间复杂度：O(1)
//时间复杂度：平均情况：O(N^2)
//			  最好情况：O(N) ---->数组有序，且为升序，只需直接插入
//			  最坏情况：O(N^2) -->数组有序，但为降序，需((1+N)*N)/2次
//
//稳定性： 【稳定】  (稳定性，就是有两个相同的元素，排序先后的相对
//		位置是否变化，主要用在排序时有多个排序规则的情况下。在插入
//		排序中，K1是已排序部分中的元素，当K2和K1比较时，直接插到K1
//		的后面(没有必要插到K1的前面，这样做还需要移动！！)，因此，
//		插入排序是稳定的。)
//
//插入排序：每次选择一个元素K插入到之前已排好序的部分A[1…i]中，插
//		入过程中K依次由后向前与A[1…i]中的元素进行比较。若发现发现
//		A[x]>=K,则将K插入到A[x]的后面，插入前需要移动元素。
//
//
//思路：1、外层循环控制插入的个数
//		2、index标记待插入数据的下标
//		3、end标记其前面数据的最后一个，eg：5 3 6 7 1 <-4  现要将4插入，则index表示的是4的下标，end是1的下标
//		4、内层循环修改位置，当待插入数据 < 前面的数据，将前面数据放在现在的end+1的位置，直至最后找到小于带插入数据的数据或当end<0(即带插入数据到达最前面的位置)
//		5、将待插入数据插入到【end+1】的位置（因为循环中有再次修改了end的位置，--end）
//


void InsertSort(int* a,int size)
{
	for (int i = 0; i < size; ++i)
	{
		int index = i;
		int end = index - 1;
		int tmp = a[i];
		while (end >= 0 && tmp < a[end])
		{
			a[end + 1] = a[end];
			--end;
		}
		a[end + 1] = tmp;
	}
}

//------------------------希尔排序(升序)-------------------//

//空间复杂度：O(1)
//时间复杂度：平均情况：O(N^1.3)
//			  最好情况：O(N) ---->数组有序，且为升序，只需直接插入
//			  最坏情况：O(N^2) -->数组有序，但为降序，需((1+N)*N)/2次
//
//稳定性：【不稳定】
//
//
//希尔排序：是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，
//	步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，
//	步长很小，插入排序对于有序的序列效率很高。所以，希尔排序的时间复
//	杂度会比o(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳
//	定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同
//	的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以
//	shell排序是【不稳定】的。
//
//思想：希尔排序也是一种插入排序方法,实际上是一种分组插入方法。先取定
//		一个小于n的整数d1作为第一个增量,把表的全部记录分成d1个组,所有
//		距离为d1的倍数的记录放在同一个组中,在各组内进行直接插入排序；
//		然后,取第二个增量d2(＜d1),重复上述的分组和排序,直至所取增量dt=1
//
//思路：1、最外层循环控制增量gap，直至增量gap==1
//		2、外层循环控制插入的个数
//		3、index标记待插入数据的下标
//		4、end标记其前面数据的前gap个，eg：5 3 6 7 1 <-4  现要将4插入，则index表示的是4的下标，end是1的下标
//		5、内层循环修改位置，当待插入数据 < 前gap的数据，将前面数据放在现在的end+gap的位置，直至最后找到小于带插入数据的数据或当end<0(即带插入数据到达最前面的位置)
//		6、将待插入数据插入到【end+gap】的位置（因为循环中有再次修改了end的位置，end=end-gap）
//		7、最后修改增量的值

void ShellSort(int* a, int size)
{
	int gap = size / 2;
	while (gap >= 1)
	{
		for (int i = 0; i < size - gap; ++i)
		{
			int index = i + gap;
			int end = index - gap;
			int tmp = a[index];
			while (end >= 0 && tmp < a[end])
			{
				a[end + gap] = a[end];
				end -= gap;
			}
			a[end + gap] = tmp;
		}
		gap = gap / 2;
	}
}


void Print(int* a,int size)
{
	for (int i = 0; i < size; ++i)
	{
		cout << a[i] << " ";
	}
	cout << endl;
}


void InsertSortTest()
{
	int a[5] = { 4, 2, 5, 3, 1 };
	Print(a, 5);
	InsertSort(a, 5);
	Print(a, 5);
}

void ShellSortTest()
{
	int a[9] = { 8, 6, 7, 0, 3, 4, 2, 5, 1 };
	Print(a, 9);
	ShellSort(a, 9);
	Print(a, 9);
}